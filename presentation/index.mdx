import { Cite, Notes, Appear } from "spectacle";
import ShipLogo from "./components/shipLogo.js";
import IncomingTransmission from "./components/IncomingTransmission";
import ShipModel from "./components/ShipModel";
import PlanetaryScan from "./components/PlanetaryScan";
import BadGuySurround from "./components/BadGuySurround";
import BadGuyHologram from "./components/BadGuyHologram";
import { DarkSlide, CodeSlide, RedAlertSlide, BlueAlertSlide } from "./slides";
import RegularComponent from "./regular-component";

<ShipLogo />

---

<ShipModel />

---

<Notes>
  This is your crew. They may look like 5th and 6th graders, but they have been
  hardened through innate determinism and minutes of training.
</Notes>

<img
  src={require("../assets/crew.jpg")}
  style={{
    position: "fixed",
    height: "100vh",
    width: "100vw",
    objectFit: "contain",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }}
/>

---

export default RedAlertSlide;

<BadGuySurround />

---

export default RedAlertSlide;

<IncomingTransmission />

<Notes>
As you are out in deep space, you recieve a threatening transmission from an alien ship.
</Notes>
---

<video
  src={require("../assets/Promo.mp4")}
  autoPlay
  style={{
    position: "fixed",
    width: "100vw",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  }}
/>

---

export default RedAlertSlide;

<span style={{ fontSize: "30vh" }}>ü§î</span>

---

export default RedAlertSlide;

<span style={{ fontSize: "30vh" }}>üèÉ‚Äç‚ôÄÔ∏è</span>

---

export default RedAlertSlide;

<span style={{ fontSize: "30vh" }}>üëä</span>

---

export default RedAlertSlide;

<div style={{ fontSize: "20vh" }}>üí°</div>
<div style={{ fontSize: "20vh" }}>üòÉ</div>

---

<img src={require("../assets/probe.svg")} style={{ height: "50vh" }} />

Science Probe

---

<img src={require("../assets/hologram.png")} style={{ height: "50vh" }} />

Hologram Projector Package

---

<BadGuyHologram />

---

<span style={{ fontSize: "30vh" }}>üß∑</span>

Safety Protocols

---

<video
  src={require("../assets/Ship Explode.mp4")}
  autoPlay
  muted
  style={{
    position: "fixed",
    height: "100vh",
    width: "100vw",
    objectFit: "contain",
    left: "0",
    right: "0",
    top: 0,
    bottom: 0
  }}
/>

---

export default BlueAlertSlide;

<span style={{ fontSize: "30vh" }}>üèÜ</span>

---

<img
  src={require("../assets/me.jpg")}
  style={{
    height: "50vh"
  }}
/>

# @ralex1993

---

> Education: the freeing of the mind through the discipline of wonder

<Cite>Mortimer Adler</Cite>

---

# Wonder-driven Development

## "I Wonder If..."

<Notes>
This is characterized by asking the question, "I wonder if...?" and then doing it.

- Curiosity about things they don't understand
- Passion for their work
- Optimism, or the belief that they can find answers

</Notes>

---

<ShipLogo />

# Thorium

---

# Learning By Doing

- React
- GraphQL & Apollo

<Notes>
I wondered if I could learn React and GraphQL while making these spaceship controls,
and even wondered if it were possible. The only way for me to find out was to do it,
so I started small, worked a bit every day, and eventually produced a completed product.

What exactly do these spaceship controls entail?

</Notes>

---

# Open Source

## [https://github.com/thorium-sim](https://github.com/thorium-sim)

<Notes>
  All of my code is available online. Anyone can see it, comment on it, change
  it, etc. It's learning in the open.
</Notes>

---

# Space Centers

---

<PlanetaryScan />

---

<video
  src={require("../assets/Space Center Map.mov")}
  controls
  style={{
    position: "fixed",
    height: "100vh",
    left: "12%",
    right: "12%",
    top: 0,
    bottom: 0
  }}
/>

---

# The Crew

---

<img
  src={require("../assets/crew.jpg")}
  style={{
    position: "fixed",
    height: "100vh",
    width: "100vw",
    objectFit: "contain",
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }}
/>

<Notes>
  Thorium is a central server that browsers connect to. Each browser has a
  client ID and can be assigned a crew station, like weapons, navigation, or
  communication.
</Notes>

---

# The Flight Director & Control Room

---

<img
  src={require("../assets/flight director.jpg")}
  style={{
    position: "fixed",
    height: "100vh",
    left: "5%",
    right: "12%",
    top: 0,
    bottom: 0
  }}
/>

---

<img
  src={require("../assets/flight director annotated.jpg")}
  style={{
    position: "fixed",
    height: "100vh",
    left: "5%",
    right: "12%",
    top: 0,
    bottom: 0
  }}
/>

<Notes>
  The flight director also connects with a web browser. They use a special
  control screen called "Core" which gives them at-a-glance access to the state
  of the simulation and the ability to adjust anything as needed.
</Notes>

---

# Ship Controls

---

<ShipLogo />

# Thorium

---

# DEMO

## I Wonder If...

---

## Dynamic Crew Stations

<Notes>
  The first problem I have to solve is showing dynamic screens on the crew
  stations. I wondered if I could control what is being shown on the client from
  the server.
</Notes>

---

```GraphQL
 subscription ClientUpdate($clientId: ID!) {
  clientChanged(client: $clientId) {
    simulator {
      id
      name
    }
    station {
      name
        cards {
          name
          component
          hidden
        }
      }
    }
  }
```

<Notes>
  Create a unique client ID, Subscribe to changes to that client ID, render the
  screen assigned to that station.
</Notes>

---

## Dynamic Control Grid

<Notes>

I wondered if I can dynamically layout core components that I can easily change
and adjust as necessary. Also have the core feed which gives me actionable
components based on things that happen during the flight. Since it's just
components, and they all load data from the unified Apollo GraphQL cache, it's
really easy to do.

</Notes>

---

# Main Viewscreen

<Notes>
  I wondered if the main viewscreen can be dynamically changed based on the
  state of the simulator.
</Notes>

---

# Mission Timeline & Mutation Macros

<Notes>
  I use an introspection query to figure out what GraphQL mutations are able to
  be used as timeline actions, and then set up special configuration for them if
  necessary
</Notes>

---

# Tracking open web browser tabs

## Multiple clients on one computer

<Notes>
  Since clients store their client ID in localstorage, it's not possible to have
  multiple clients open at the same time... unless I store a list of clients in
  localstorage
</Notes>

---

```JavaScript
broadcastChannel.postMessage("clientPing");
// Lets give a bit of time for the windows to get back
setTimeout(() => {
  if (clientId) {
    return resolve(clientId);
  }
  for (let i = 0; i < clientList.length; i++) {
    if (!windows.includes(clientList[i])) {
      setClient(clientList[i]);
      return resolve(clientId);
    }
  }
  if (!clientId) {
    setClient(randomWords(3).join("-"));
    clientList.push(clientId);
    localStorage.setItem(key, JSON.stringify(clientList));
    return resolve(clientId);
  }
}, 500);
```

<Notes>
  I have a little Marco-polo session with the open tab, where a new tabs pings
  other other tabs so it can find out which tab number it is. Then it grabs that
  clientId from the localStorage array. If you know a better way, hit me up on
  Twitter.
</Notes>

---

# Subscription-based Animations

<Notes>
  Server animated contacts at 20fps and LERP on the client. This was just
  playing around with Websockets, animation intervals, and different Linear
  Interpolation methods.
</Notes>

---

## Before

```JavaScript

export default function useInterpolate(inputs, interval) {
  const [contacts, setContacts] = useState(inputs);
  const endTime = useRef(Date.now() + interval);
  const previousInputs = usePrevious(inputs);
  const inputsRef = useRef(inputs);
  useEffect(() => {
    endTime.current = Date.now() + interval;
    inputsRef.current = inputs;
  }, [inputs, interval]);

  useAnimationFrame(() => {
    let t = Math.max(
      0,
      Math.min(1, Math.abs(1 - (endTime.current - Date.now()) / interval))
    );
    const contactIds = contacts.map(c => c.id);
    const inputObj = inputsRef.current.reduce(
      (acc, c) => ({ ...acc, [c.id]: c }),
      {}
    );
    const previousInputObj = previousInputs.reduce(
      (acc, c) => ({ ...acc, [c.id]: c }),
      {}
    );
    const inputIds = Object.keys(inputObj);
    const newContacts = inputsRef.current.filter(
      ({ id }) => contactIds.indexOf(id) === -1
    );
    const filteredContacts = contacts
      .filter(({ id }) => inputIds.indexOf(id) > -1)
      .map(c => {
        if (!previousInputObj[c.id] || !inputObj[c.id]) return null;
        return {
          ...c,
          ...inputObj[c.id],
          position: {
            x: lerp(
              previousInputObj[c.id].position.x,
              inputObj[c.id].position.x,
              t
            ),
            y: lerp(
              previousInputObj[c.id].position.y,
              inputObj[c.id].position.y,
              t
            )
          }
        };
      })
      .filter(Boolean);
    setContacts(newContacts.concat(filteredContacts));
  });
  return contacts;
}
```

---

## After

```CSS
.moving-object {
  transform: translate 50ms linear;
}
```

<Notes>
  As it turns out, CSS is way better at interpolating things than JavaScript
</Notes>

---

# More Wonders

- React Component Plugins with React.lazy
- Patch-based GraphQL subscriptions
- React renderer for DMX lighting

---

# Future Plans

<br />
 
Or what I would do if I did it all over again

<Notes>
I would start with a partner or team. And I would think about making it more friendly to more users.

I wrote a list of 10 things that I would do differently if I did it all over
again. I'm going to revisit them in 3 years and see how many stand the tests of
time.

    1. Use TypeScript
    2. Use the latest features of all the frameworks - hooks, suspense, etc.
    3. Use CSS-in-JS so the CSS isn‚Äôt a total nightmare (it‚Äôs not too bad, since it‚Äôs all scoped to cards, but there are still collisions sometimes that cause problems)
    4. More carefully design the GraphQL schema so it‚Äôs consistent.
    5. Make sure subscriptions are more atomic and scoped to just what the subscriber wants (there are currently a LOT of leaky subscriptions)
    6. Do internationalization from the get-go
    7. Do a11y from the get-go
    8. Use a more proper database. My JSON dump works for most peeps, but Ryan Anderson has a MASSIVE snapshot, and his CPU spikes hardcore every time it writes.
    9. Simplify things substantially based on how users actually use Thorium. More sensible defaults, less enterprise-y, less configuration
    10. Write Tests

</Notes>

---

# How do you wonder?

- Have a crazy idea
- Write it down
- Think about it
- Come back to it

---

# Wonder-driven Development

> I wonder if...

---

<div style={{ display: "flex", justifyContent:"space-between", alignItems:"center", marginLeft:"-10vw", width:"80vw" }}>
  <div>
    <h1>Thanks!</h1>
    <h2><a href="https://thoriumsim.com">https://ThoriumSim.com</a></h2>
    <h2><a href="https://twitter.com/ralex1993">@ralex1993</a></h2>
  </div>
  <img src={require("../assets/hero.jpg")} style={{ height: "70vh", width:"40vw", objectFit:"cover" }} />

</div>

---
